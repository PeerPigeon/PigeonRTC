var PigeonRTC=(()=>{var C=Object.create;var p=Object.defineProperty;var g=Object.getOwnPropertyDescriptor;var f=Object.getOwnPropertyNames;var m=Object.getPrototypeOf,y=Object.prototype.hasOwnProperty;var R=(n=>typeof require<"u"?require:typeof Proxy<"u"?new Proxy(n,{get:(e,t)=>(typeof require<"u"?require:e)[t]}):n)(function(n){if(typeof require<"u")return require.apply(this,arguments);throw Error('Dynamic require of "'+n+'" is not supported')});var v=(n,e)=>{for(var t in e)p(n,t,{get:e[t],enumerable:!0})},w=(n,e,t,i)=>{if(e&&typeof e=="object"||typeof e=="function")for(let r of f(e))!y.call(n,r)&&r!==t&&p(n,r,{get:()=>e[r],enumerable:!(i=g(e,r))||i.enumerable});return n};var T=(n,e,t)=>(t=n!=null?C(m(n)):{},w(e||!n||!n.__esModule?p(t,"default",{value:n,enumerable:!0}):t,n)),E=n=>w(p({},"__esModule",{value:!0}),n);var I={};v(I,{BrowserRTCAdapter:()=>d,NodeRTCAdapter:()=>c,PeerConnection:()=>o,PigeonRTC:()=>h,RTCAdapter:()=>s,SignalingClient:()=>a,createPigeonRTC:()=>l,default:()=>M});var s=class{getRTCPeerConnection(){throw new Error("getRTCPeerConnection must be implemented by adapter")}getRTCSessionDescription(){throw new Error("getRTCSessionDescription must be implemented by adapter")}getRTCIceCandidate(){throw new Error("getRTCIceCandidate must be implemented by adapter")}getMediaStream(){return null}isSupported(){throw new Error("isSupported must be implemented by adapter")}getName(){throw new Error("getName must be implemented by adapter")}async initialize(){}async getUserMedia(e){throw new Error("getUserMedia not supported by this adapter")}async getDisplayMedia(e){throw new Error("getDisplayMedia not supported by this adapter")}};var d=class extends s{constructor(){super(),this._checkSupport()}_checkSupport(){typeof window>"u"||typeof navigator>"u"||(this.hasRTCPeerConnection=!!(window.RTCPeerConnection||window.webkitRTCPeerConnection||window.mozRTCPeerConnection),this.hasGetUserMedia=!!(navigator.mediaDevices?.getUserMedia||navigator.getUserMedia||navigator.webkitGetUserMedia||navigator.mozGetUserMedia),this.hasGetDisplayMedia=!!navigator.mediaDevices?.getDisplayMedia)}getRTCPeerConnection(){if(typeof window>"u")throw new Error("BrowserRTCAdapter requires a browser environment");return window.RTCPeerConnection||window.webkitRTCPeerConnection||window.mozRTCPeerConnection}getRTCSessionDescription(){if(typeof window>"u")throw new Error("BrowserRTCAdapter requires a browser environment");return window.RTCSessionDescription||window.mozRTCSessionDescription}getRTCIceCandidate(){if(typeof window>"u")throw new Error("BrowserRTCAdapter requires a browser environment");return window.RTCIceCandidate||window.mozRTCIceCandidate}getMediaStream(){return typeof window>"u"?null:window.MediaStream||window.webkitMediaStream}isSupported(){return typeof window<"u"&&this.hasRTCPeerConnection}getName(){return"BrowserRTCAdapter"}async getUserMedia(e){if(typeof navigator>"u")throw new Error("getUserMedia requires a browser environment");if(navigator.mediaDevices?.getUserMedia)return await navigator.mediaDevices.getUserMedia(e);let t=navigator.getUserMedia||navigator.webkitGetUserMedia||navigator.mozGetUserMedia;if(!t)throw new Error("getUserMedia is not supported in this browser");return new Promise((i,r)=>{t.call(navigator,e,i,r)})}async getDisplayMedia(e){if(typeof navigator>"u")throw new Error("getDisplayMedia requires a browser environment");if(!navigator.mediaDevices?.getDisplayMedia)throw new Error("getDisplayMedia is not supported in this browser");return await navigator.mediaDevices.getDisplayMedia(e)}};var c=class extends s{constructor(){super(),this._wrtc=null,this._initialized=!1}async initialize(){if(!this._initialized)try{let e=await import("@koush/wrtc");this._wrtc=e.default||e,this._initialized=!0}catch{throw new Error("NodeRTCAdapter requires @koush/wrtc to be installed. Install it with: npm install @koush/wrtc")}}_ensureInitialized(){if(!this._initialized||!this._wrtc)throw new Error("NodeRTCAdapter not initialized. Call initialize() first.")}getRTCPeerConnection(){return this._ensureInitialized(),this._wrtc.RTCPeerConnection}getRTCSessionDescription(){return this._ensureInitialized(),this._wrtc.RTCSessionDescription}getRTCIceCandidate(){return this._ensureInitialized(),this._wrtc.RTCIceCandidate}getMediaStream(){return this._ensureInitialized(),this._wrtc.MediaStream||null}isSupported(){return typeof process<"u"&&process.versions!=null&&process.versions.node!=null&&typeof window>"u"}getName(){return"NodeRTCAdapter"}async getUserMedia(e){throw new Error("getUserMedia is not supported in Node.js environment")}async getDisplayMedia(e){throw new Error("getDisplayMedia is not supported in Node.js environment")}};var a=class extends EventTarget{constructor(e){super(),this.serverUrl=e,this.ws=null,this.clientId=null,this.connected=!1,this.reconnectAttempts=0,this.maxReconnectAttempts=5,this.reconnectDelay=1e3}connect(){return new Promise((e,t)=>{try{this.ws=new WebSocket(this.serverUrl),this.ws.onopen=()=>{this.connected=!0,this.reconnectAttempts=0,this.dispatchEvent(new CustomEvent("connected")),e()},this.ws.onmessage=i=>{try{let r=JSON.parse(i.data);this.handleMessage(r)}catch(r){console.error("Error parsing message:",r)}},this.ws.onerror=i=>{this.dispatchEvent(new CustomEvent("error",{detail:i})),t(i)},this.ws.onclose=()=>{this.connected=!1,this.dispatchEvent(new CustomEvent("disconnected")),this.attemptReconnect()}}catch(i){t(i)}})}handleMessage(e){switch(e.type){case"id":this.clientId=e.id,this.dispatchEvent(new CustomEvent("id",{detail:{id:e.id}}));break;case"clients":this.dispatchEvent(new CustomEvent("clients",{detail:{clients:e.clients}}));break;case"offer":case"answer":case"ice-candidate":this.dispatchEvent(new CustomEvent("signal",{detail:e}));break;default:console.warn("Unknown message type:",e.type)}}send(e){if(this.ws&&this.ws.readyState===WebSocket.OPEN)this.ws.send(JSON.stringify(e));else throw new Error("WebSocket not connected")}sendOffer(e,t){this.send({type:"offer",to:e,offer:t})}sendAnswer(e,t){this.send({type:"answer",to:e,answer:t})}sendIceCandidate(e,t){this.send({type:"ice-candidate",to:e,candidate:t})}attemptReconnect(){this.reconnectAttempts<this.maxReconnectAttempts&&(this.reconnectAttempts++,setTimeout(()=>{console.log(`Reconnecting... attempt ${this.reconnectAttempts}`),this.connect().catch(e=>{console.error("Reconnect failed:",e)})},this.reconnectDelay*this.reconnectAttempts))}disconnect(){this.ws&&(this.ws.close(),this.ws=null,this.connected=!1,this.clientId=null)}isConnected(){return this.connected&&this.ws&&this.ws.readyState===WebSocket.OPEN}getClientId(){return this.clientId}};var o=class extends EventTarget{constructor(e,t,i={}){super(),this.rtc=e,this.signaling=t,this.config=i,this.pc=null,this.dataChannels=new Map,this.remoteId=null,this.isInitiator=!1}_init(){this.pc=this.rtc.createPeerConnection(this.config),this.pc.onicecandidate=e=>{e.candidate&&this.remoteId&&this.signaling.sendIceCandidate(this.remoteId,e.candidate)},this.pc.onconnectionstatechange=()=>{this.dispatchEvent(new CustomEvent("connectionstatechange",{detail:this.pc.connectionState})),this.pc.connectionState==="connected"?this.dispatchEvent(new CustomEvent("connected")):this.pc.connectionState==="failed"&&this.dispatchEvent(new CustomEvent("failed"))},this.pc.oniceconnectionstatechange=()=>{this.dispatchEvent(new CustomEvent("iceconnectionstatechange",{detail:this.pc.iceConnectionState}))},this.pc.ontrack=e=>{this.dispatchEvent(new CustomEvent("track",{detail:{track:e.track,streams:e.streams}}))},this.pc.ondatachannel=e=>{let t=e.channel;this.dataChannels.set(t.label,t),this._setupDataChannel(t),this.dispatchEvent(new CustomEvent("datachannel",{detail:t}))}}async connect(e,t=null){this.remoteId=e,this.isInitiator=!0,this._init(),t&&t.getTracks().forEach(r=>{this.pc.addTrack(r,t)});let i=await this.pc.createOffer();await this.pc.setLocalDescription(i),this.signaling.sendOffer(e,i)}async handleOffer(e,t,i=null){this.remoteId=e,this.isInitiator=!1,this._init(),i&&i.getTracks().forEach(u=>{this.pc.addTrack(u,i)}),await this.pc.setRemoteDescription(t);let r=await this.pc.createAnswer();await this.pc.setLocalDescription(r),this.signaling.sendAnswer(e,r)}async handleAnswer(e){await this.pc.setRemoteDescription(e)}async handleIceCandidate(e){this.pc&&await this.pc.addIceCandidate(e)}createDataChannel(e,t={}){if(!this.pc)throw new Error("Peer connection not initialized");let i=this.pc.createDataChannel(e,t);return this.dataChannels.set(e,i),this._setupDataChannel(i),i}_setupDataChannel(e){e.onopen=()=>{this.dispatchEvent(new CustomEvent("channelopen",{detail:e}))},e.onmessage=t=>{this.dispatchEvent(new CustomEvent("message",{detail:{channel:e.label,data:t.data}}))},e.onclose=()=>{this.dataChannels.delete(e.label),this.dispatchEvent(new CustomEvent("channelclose",{detail:e}))}}send(e,t){let i=this.dataChannels.get(e);if(i&&i.readyState==="open")i.send(t);else throw new Error(`Channel ${e} not open`)}getDataChannel(e){return this.dataChannels.get(e)}getRTCPeerConnection(){return this.pc}close(){this.pc&&(this.pc.close(),this.pc=null),this.dataChannels.clear(),this.remoteId=null}};var h=class{constructor(e={}){this.adapter=e.adapter||null,this.initialized=!1}async initialize(e={}){this.initialized||(e.adapter&&(this.adapter=e.adapter),this.adapter||(this.adapter=await this._detectAdapter(e)),await this.adapter.initialize(),this.initialized=!0)}async _detectAdapter(e={}){if(e.preferNode||typeof window>"u"&&typeof process<"u"){let i=new c;if(i.isSupported())try{return await i.initialize(),i}catch(r){console.warn("Node adapter initialization failed, trying browser adapter:",r.message)}}let t=new d;if(t.isSupported())return t;throw new Error("No supported WebRTC adapter found. Make sure you are running in a browser with WebRTC support or have @koush/wrtc installed for Node.js.")}_ensureInitialized(){if(!this.initialized||!this.adapter)throw new Error("PigeonRTC not initialized. Call initialize() first.")}getRTCPeerConnection(){return this._ensureInitialized(),this.adapter.getRTCPeerConnection()}getRTCSessionDescription(){return this._ensureInitialized(),this.adapter.getRTCSessionDescription()}getRTCIceCandidate(){return this._ensureInitialized(),this.adapter.getRTCIceCandidate()}getMediaStream(){return this._ensureInitialized(),this.adapter.getMediaStream()}createPeerConnection(e){this._ensureInitialized();let t=this.adapter.getRTCPeerConnection();return new t(e)}createSessionDescription(e){this._ensureInitialized();let t=this.adapter.getRTCSessionDescription();return new t(e)}createIceCandidate(e){this._ensureInitialized();let t=this.adapter.getRTCIceCandidate();return new t(e)}async getUserMedia(e){return this._ensureInitialized(),await this.adapter.getUserMedia(e)}async getDisplayMedia(e){return this._ensureInitialized(),await this.adapter.getDisplayMedia(e)}isSupported(){return this.adapter?this.adapter.isSupported():!1}getAdapterName(){return this.adapter?this.adapter.getName():"None"}createSignalingClient(e){return new a(e)}createManagedPeerConnection(e,t={}){return this._ensureInitialized(),new o(this,e,t)}};async function l(n={}){let e=new h(n);return await e.initialize(n),e}var M=l;return E(I);})();
//# sourceMappingURL=browser.min.js.map
