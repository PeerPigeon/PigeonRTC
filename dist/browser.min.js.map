{
  "version": 3,
  "sources": ["../src/index.js", "../src/RTCAdapter.js", "../src/BrowserRTCAdapter.js", "../src/NodeRTCAdapter.js", "../src/SignalingClient.js", "../src/MDNSResolver.js", "../src/PeerConnection.js", "../src/PigeonRTC.js"],
  "sourcesContent": ["/**\n * PigeonRTC - Pluggable cross-browser compatible WebRTC library\n * \n * A lightweight, pluggable WebRTC library that provides a consistent API\n * across different environments (browser and Node.js) with support for\n * custom adapters.\n * \n * @module pigeonrtc\n */\n\nexport { PigeonRTC, createPigeonRTC, SignalingClient, PeerConnection } from './PigeonRTC.js';\nexport { RTCAdapter } from './RTCAdapter.js';\nexport { BrowserRTCAdapter } from './BrowserRTCAdapter.js';\nexport { NodeRTCAdapter } from './NodeRTCAdapter.js';\nexport { MDNSResolver } from './MDNSResolver.js';\n\n// Default export for convenience\nimport { createPigeonRTC } from './PigeonRTC.js';\nexport default createPigeonRTC;\n", "/**\n * Base RTCAdapter interface that all WebRTC adapters must implement.\n * This provides a consistent API regardless of the underlying WebRTC implementation.\n */\nexport class RTCAdapter {\n  /**\n   * Get the RTCPeerConnection class for this adapter\n   * @returns {typeof RTCPeerConnection} The RTCPeerConnection class\n   */\n  getRTCPeerConnection() {\n    throw new Error('getRTCPeerConnection must be implemented by adapter');\n  }\n\n  /**\n   * Get the RTCSessionDescription class for this adapter\n   * @returns {typeof RTCSessionDescription} The RTCSessionDescription class\n   */\n  getRTCSessionDescription() {\n    throw new Error('getRTCSessionDescription must be implemented by adapter');\n  }\n\n  /**\n   * Get the RTCIceCandidate class for this adapter\n   * @returns {typeof RTCIceCandidate} The RTCIceCandidate class\n   */\n  getRTCIceCandidate() {\n    throw new Error('getRTCIceCandidate must be implemented by adapter');\n  }\n\n  /**\n   * Get the MediaStream class for this adapter (if supported)\n   * @returns {typeof MediaStream|null} The MediaStream class or null if not supported\n   */\n  getMediaStream() {\n    return null;\n  }\n\n  /**\n   * Check if this adapter supports the current environment\n   * @returns {boolean} True if the adapter can work in the current environment\n   */\n  isSupported() {\n    throw new Error('isSupported must be implemented by adapter');\n  }\n\n  /**\n   * Get the name of this adapter\n   * @returns {string} The adapter name\n   */\n  getName() {\n    throw new Error('getName must be implemented by adapter');\n  }\n\n  /**\n   * Initialize the adapter (for any setup that needs to happen)\n   * @returns {Promise<void>}\n   */\n  async initialize() {\n    // Default implementation does nothing\n  }\n\n  /**\n   * Get user media (if supported)\n   * @param {MediaStreamConstraints} _constraints\n   * @returns {Promise<MediaStream>}\n   */\n  async getUserMedia(_constraints) {\n    throw new Error('getUserMedia not supported by this adapter');\n  }\n\n  /**\n   * Get display media (if supported)\n   * @param {MediaStreamConstraints} _constraints\n   * @returns {Promise<MediaStream>}\n   */\n  async getDisplayMedia(_constraints) {\n    throw new Error('getDisplayMedia not supported by this adapter');\n  }\n}\n", "import { RTCAdapter } from './RTCAdapter.js';\n\n/**\n * Browser-native WebRTC adapter for use in web browsers.\n * This adapter uses the browser's native WebRTC implementation.\n */\nexport class BrowserRTCAdapter extends RTCAdapter {\n  constructor() {\n    super();\n    this._checkSupport();\n  }\n\n  _checkSupport() {\n    // Check if we're in a browser environment\n    if (typeof window === 'undefined' || typeof navigator === 'undefined') {\n      return;\n    }\n\n    // Browser environment - check for WebRTC support\n    this.hasRTCPeerConnection = !!(\n      window.RTCPeerConnection ||\n      window.webkitRTCPeerConnection ||\n      window.mozRTCPeerConnection\n    );\n\n    this.hasGetUserMedia = !!(\n      navigator.mediaDevices?.getUserMedia ||\n      navigator.getUserMedia ||\n      navigator.webkitGetUserMedia ||\n      navigator.mozGetUserMedia\n    );\n\n    this.hasGetDisplayMedia = !!(\n      navigator.mediaDevices?.getDisplayMedia\n    );\n  }\n\n  getRTCPeerConnection() {\n    if (typeof window === 'undefined') {\n      throw new Error('BrowserRTCAdapter requires a browser environment');\n    }\n\n    return window.RTCPeerConnection ||\n           window.webkitRTCPeerConnection ||\n           window.mozRTCPeerConnection;\n  }\n\n  getRTCSessionDescription() {\n    if (typeof window === 'undefined') {\n      throw new Error('BrowserRTCAdapter requires a browser environment');\n    }\n\n    return window.RTCSessionDescription ||\n           window.mozRTCSessionDescription;\n  }\n\n  getRTCIceCandidate() {\n    if (typeof window === 'undefined') {\n      throw new Error('BrowserRTCAdapter requires a browser environment');\n    }\n\n    return window.RTCIceCandidate ||\n           window.mozRTCIceCandidate;\n  }\n\n  getMediaStream() {\n    if (typeof window === 'undefined') {\n      return null;\n    }\n\n    return window.MediaStream || window.webkitMediaStream;\n  }\n\n  isSupported() {\n    return typeof window !== 'undefined' && this.hasRTCPeerConnection;\n  }\n\n  getName() {\n    return 'BrowserRTCAdapter';\n  }\n\n  async getUserMedia(constraints) {\n    if (typeof navigator === 'undefined') {\n      throw new Error('getUserMedia requires a browser environment');\n    }\n\n    // Modern API\n    if (navigator.mediaDevices?.getUserMedia) {\n      return await navigator.mediaDevices.getUserMedia(constraints);\n    }\n\n    // Legacy API with Promise wrapper\n    const getUserMedia = navigator.getUserMedia ||\n                        navigator.webkitGetUserMedia ||\n                        navigator.mozGetUserMedia;\n\n    if (!getUserMedia) {\n      throw new Error('getUserMedia is not supported in this browser');\n    }\n\n    return new Promise((resolve, reject) => {\n      getUserMedia.call(navigator, constraints, resolve, reject);\n    });\n  }\n\n  async getDisplayMedia(constraints) {\n    if (typeof navigator === 'undefined') {\n      throw new Error('getDisplayMedia requires a browser environment');\n    }\n\n    if (!navigator.mediaDevices?.getDisplayMedia) {\n      throw new Error('getDisplayMedia is not supported in this browser');\n    }\n\n    return await navigator.mediaDevices.getDisplayMedia(constraints);\n  }\n}\n", "import { RTCAdapter } from './RTCAdapter.js';\n\n/**\n * Node.js WebRTC adapter using @koush/wrtc package.\n * This adapter provides WebRTC functionality in Node.js environments.\n */\nexport class NodeRTCAdapter extends RTCAdapter {\n  constructor() {\n    super();\n    this._wrtc = null;\n    this._initialized = false;\n  }\n\n  async initialize() {\n    if (this._initialized) {\n      return;\n    }\n\n    try {\n      // Dynamically import @koush/wrtc (it's an optional peer dependency)\n      const wrtcModule = await import('@koush/wrtc');\n      // Handle both default export (ES modules) and named exports (CommonJS)\n      this._wrtc = wrtcModule.default || wrtcModule;\n      this._initialized = true;\n    } catch (error) {\n      throw new Error(\n        'NodeRTCAdapter requires @koush/wrtc to be installed. ' +\n        'Install it with: npm install @koush/wrtc'\n      );\n    }\n  }\n\n  _ensureInitialized() {\n    if (!this._initialized || !this._wrtc) {\n      throw new Error(\n        'NodeRTCAdapter not initialized. Call initialize() first.'\n      );\n    }\n  }\n\n  getRTCPeerConnection() {\n    this._ensureInitialized();\n    return this._wrtc.RTCPeerConnection;\n  }\n\n  getRTCSessionDescription() {\n    this._ensureInitialized();\n    return this._wrtc.RTCSessionDescription;\n  }\n\n  getRTCIceCandidate() {\n    this._ensureInitialized();\n    return this._wrtc.RTCIceCandidate;\n  }\n\n  getMediaStream() {\n    this._ensureInitialized();\n    return this._wrtc.MediaStream || null;\n  }\n\n  isSupported() {\n    // Check if we're in a Node.js environment (not browser)\n    return typeof process !== 'undefined' &&\n           process.versions != null &&\n           process.versions.node != null &&\n           typeof window === 'undefined';\n  }\n\n  getName() {\n    return 'NodeRTCAdapter';\n  }\n\n  async getUserMedia(_constraints) {\n    // Node.js doesn't typically support getUserMedia\n    // This would require additional hardware access libraries\n    throw new Error('getUserMedia is not supported in Node.js environment');\n  }\n\n  async getDisplayMedia(_constraints) {\n    // Node.js doesn't support getDisplayMedia\n    throw new Error('getDisplayMedia is not supported in Node.js environment');\n  }\n}\n", "/**\n * WebSocket signaling client for PigeonRTC\n * Handles peer discovery and WebRTC signaling over WebSocket\n */\nexport class SignalingClient extends EventTarget {\n  constructor(serverUrl) {\n    super();\n    this.serverUrl = serverUrl;\n    this.ws = null;\n    this.clientId = null;\n    this.connected = false;\n    this.reconnectAttempts = 0;\n    this.maxReconnectAttempts = 5;\n    this.reconnectDelay = 1000;\n  }\n\n  /**\n   * Connect to the signaling server\n   * @returns {Promise<void>}\n   */\n  connect() {\n    return new Promise((resolve, reject) => {\n      try {\n        this.ws = new WebSocket(this.serverUrl);\n        \n        this.ws.onopen = () => {\n          this.connected = true;\n          this.reconnectAttempts = 0;\n          this.dispatchEvent(new CustomEvent('connected'));\n          resolve();\n        };\n        \n        this.ws.onmessage = (event) => {\n          try {\n            const message = JSON.parse(event.data);\n            this.handleMessage(message);\n          } catch (err) {\n            console.error('Error parsing message:', err);\n          }\n        };\n        \n        this.ws.onerror = (error) => {\n          this.dispatchEvent(new CustomEvent('error', { detail: error }));\n          reject(error);\n        };\n        \n        this.ws.onclose = () => {\n          this.connected = false;\n          this.dispatchEvent(new CustomEvent('disconnected'));\n          this.attemptReconnect();\n        };\n        \n      } catch (err) {\n        reject(err);\n      }\n    });\n  }\n\n  /**\n   * Handle incoming messages from signaling server\n   * @private\n   */\n  handleMessage(message) {\n    switch (message.type) {\n    case 'id':\n      this.clientId = message.id;\n      this.dispatchEvent(new CustomEvent('id', { detail: { id: message.id } }));\n      break;\n        \n    case 'clients':\n      this.dispatchEvent(new CustomEvent('clients', { detail: { clients: message.clients } }));\n      break;\n        \n    case 'offer':\n    case 'answer':\n    case 'ice-candidate':\n      this.dispatchEvent(new CustomEvent('signal', { detail: message }));\n      break;\n        \n    default:\n      console.warn('Unknown message type:', message.type);\n    }\n  }\n\n  /**\n   * Send a message to the signaling server\n   * @param {Object} message - Message to send\n   */\n  send(message) {\n    if (this.ws && this.ws.readyState === WebSocket.OPEN) {\n      this.ws.send(JSON.stringify(message));\n    } else {\n      throw new Error('WebSocket not connected');\n    }\n  }\n\n  /**\n   * Send an offer to a peer\n   * @param {string|number} peerId - Target peer ID\n   * @param {RTCSessionDescriptionInit} offer - WebRTC offer\n   */\n  sendOffer(peerId, offer) {\n    this.send({\n      type: 'offer',\n      to: peerId,\n      offer: offer\n    });\n  }\n\n  /**\n   * Send an answer to a peer\n   * @param {string|number} peerId - Target peer ID\n   * @param {RTCSessionDescriptionInit} answer - WebRTC answer\n   */\n  sendAnswer(peerId, answer) {\n    this.send({\n      type: 'answer',\n      to: peerId,\n      answer: answer\n    });\n  }\n\n  /**\n   * Send an ICE candidate to a peer\n   * @param {string|number} peerId - Target peer ID\n   * @param {RTCIceCandidateInit} candidate - ICE candidate\n   */\n  sendIceCandidate(peerId, candidate) {\n    this.send({\n      type: 'ice-candidate',\n      to: peerId,\n      candidate: candidate\n    });\n  }\n\n  /**\n   * Attempt to reconnect to the signaling server\n   * @private\n   */\n  attemptReconnect() {\n    if (this.reconnectAttempts < this.maxReconnectAttempts) {\n      this.reconnectAttempts++;\n      setTimeout(() => {\n        console.log(`Reconnecting... attempt ${this.reconnectAttempts}`);\n        this.connect().catch(err => {\n          console.error('Reconnect failed:', err);\n        });\n      }, this.reconnectDelay * this.reconnectAttempts);\n    }\n  }\n\n  /**\n   * Disconnect from the signaling server\n   */\n  disconnect() {\n    if (this.ws) {\n      this.ws.close();\n      this.ws = null;\n      this.connected = false;\n      this.clientId = null;\n    }\n  }\n\n  /**\n   * Check if connected to signaling server\n   * @returns {boolean}\n   */\n  isConnected() {\n    return this.connected && this.ws && this.ws.readyState === WebSocket.OPEN;\n  }\n\n  /**\n   * Get client ID\n   * @returns {string|number|null}\n   */\n  getClientId() {\n    return this.clientId;\n  }\n}\n", "/**\n * mDNS Resolver for handling .local ICE candidates\n * Uses pigeonns for resolving mDNS hostnames to IP addresses\n * Supports both Node.js (direct mDNS) and Browser (HTTP API) environments\n */\nexport class MDNSResolver {\n  constructor(options = {}) {\n    this._resolver = null;\n    this._initialized = false;\n    this._cache = new Map();\n    this._cacheTimeout = 60000; // 60 seconds cache TTL\n    this._mode = null; // 'node' or 'browser'\n    this._serverUrl = options.serverUrl || 'http://localhost:5380'; // pigeonns HTTP server\n  }\n\n  /**\n   * Initialize the mDNS resolver\n   * Automatically detects Node.js vs Browser environment\n   * @returns {Promise<void>}\n   */\n  async initialize() {\n    if (this._initialized) {\n      return;\n    }\n\n    // Detect environment\n    const isNode = typeof process !== 'undefined' && \n                   process.versions != null && \n                   process.versions.node != null;\n\n    if (isNode) {\n      // Node.js: Use direct mDNS resolver\n      try {\n        const pigeonnsModule = await import('pigeonns');\n        const MDNSResolver = pigeonnsModule.default || pigeonnsModule;\n        this._resolver = new MDNSResolver({\n          timeout: 5000,\n          ttl: 60, // Match our cache timeout\n          cacheSize: 1000\n        });\n        this._resolver.start();\n        this._mode = 'node';\n        this._initialized = true;\n        console.log('\u2713 mDNS resolver initialized (Node.js mode)');\n      } catch (error) {\n        console.warn('Failed to initialize Node.js mDNS resolver:', error.message);\n        this._initialized = false;\n      }\n    } else {\n      // Browser: Use HTTP API client\n      try {\n        // Test if pigeonns server is available\n        const response = await fetch(`${this._serverUrl}/health`, {\n          method: 'GET',\n          signal: AbortSignal.timeout(2000) // 2 second timeout\n        });\n        \n        if (response.ok) {\n          this._mode = 'browser';\n          this._initialized = true;\n          console.log(`\u2713 mDNS resolver initialized (Browser mode) - Server: ${this._serverUrl}`);\n        } else {\n          console.warn(`pigeonns server not responding at ${this._serverUrl}`);\n          this._initialized = false;\n        }\n      } catch (error) {\n        console.warn(`Failed to connect to pigeonns server at ${this._serverUrl}:`, error.message);\n        console.warn('mDNS resolution will be disabled. Start pigeonns server with: npx pigeonns serve');\n        this._initialized = false;\n      }\n    }\n  }\n\n  /**\n   * Check if the resolver is available and initialized\n   * @returns {boolean}\n   */\n  isAvailable() {\n    return this._initialized && this._resolver !== null;\n  }\n\n  /**\n   * Check if an ICE candidate contains a .local hostname\n   * @param {RTCIceCandidateInit} candidate - ICE candidate to check\n   * @returns {boolean}\n   */\n  isLocalCandidate(candidate) {\n    if (!candidate || !candidate.candidate) {\n      return false;\n    }\n\n    // Check if the candidate string contains .local\n    return candidate.candidate.includes('.local');\n  }\n\n  /**\n   * Extract hostname from ICE candidate string\n   * @param {string} candidateString - ICE candidate string\n   * @returns {string|null} - Extracted hostname or null\n   * @private\n   */\n  _extractHostname(candidateString) {\n    // ICE candidate format: \"candidate:... typ ... ...\"\n    // Example: \"candidate:1 1 udp 2113937151 hostname.local 54321 typ host\"\n    const parts = candidateString.split(' ');\n    \n    for (let i = 0; i < parts.length; i++) {\n      if (parts[i].endsWith('.local')) {\n        return parts[i];\n      }\n    }\n    \n    return null;\n  }\n\n  /**\n   * Get cached IP address for hostname\n   * @param {string} hostname - Hostname to lookup\n   * @returns {string|null}\n   * @private\n   */\n  _getCachedIP(hostname) {\n    const cached = this._cache.get(hostname);\n    if (cached && Date.now() - cached.timestamp < this._cacheTimeout) {\n      return cached.ip;\n    }\n    return null;\n  }\n\n  /**\n   * Set cached IP address for hostname\n   * @param {string} hostname - Hostname to cache\n   * @param {string} ip - IP address to cache\n   * @private\n   */\n  _setCachedIP(hostname, ip) {\n    this._cache.set(hostname, {\n      ip,\n      timestamp: Date.now()\n    });\n  }\n\n  /**\n   * Resolve a .local hostname to an IP address using mDNS\n   * Works in both Node.js (direct mDNS) and Browser (HTTP API) modes\n   * @param {string} hostname - Hostname to resolve (e.g., \"myhost.local\")\n   * @returns {Promise<string|null>} - Resolved IP address or null if resolution fails\n   */\n  async resolve(hostname) {\n    if (!this.isAvailable()) {\n      console.warn('mDNS resolver not available');\n      return null;\n    }\n\n    // Check cache first\n    const cachedIP = this._getCachedIP(hostname);\n    if (cachedIP) {\n      return cachedIP;\n    }\n\n    try {\n      let ip = null;\n\n      if (this._mode === 'node') {\n        // Node.js: Use direct mDNS resolver\n        ip = await this._resolver.resolve(hostname, 'A');\n      } else if (this._mode === 'browser') {\n        // Browser: Use HTTP API\n        const response = await fetch(\n          `${this._serverUrl}/resolve?name=${encodeURIComponent(hostname)}&type=A`,\n          {\n            method: 'GET',\n            signal: AbortSignal.timeout(5000) // 5 second timeout\n          }\n        );\n\n        if (response.ok) {\n          const data = await response.json();\n          ip = data.address;\n        } else {\n          console.warn(`Failed to resolve ${hostname}: HTTP ${response.status}`);\n        }\n      }\n      \n      if (ip) {\n        this._setCachedIP(hostname, ip);\n        return ip;\n      }\n      \n      return null;\n    } catch (error) {\n      console.warn(`Failed to resolve ${hostname}:`, error.message);\n      return null;\n    }\n  }\n\n  /**\n   * Resolve an ICE candidate that contains a .local hostname\n   * Returns a new candidate with the hostname replaced by the IP address\n   * @param {RTCIceCandidateInit} candidate - ICE candidate to resolve\n   * @returns {Promise<RTCIceCandidateInit|null>} - Resolved candidate or null\n   */\n  async resolveCandidate(candidate) {\n    if (!candidate || !candidate.candidate) {\n      return null;\n    }\n\n    if (!this.isLocalCandidate(candidate)) {\n      // Not a .local candidate, return as-is\n      return candidate;\n    }\n\n    const hostname = this._extractHostname(candidate.candidate);\n    if (!hostname) {\n      console.warn('Could not extract hostname from candidate:', candidate.candidate);\n      return null;\n    }\n\n    const ip = await this.resolve(hostname);\n    if (!ip) {\n      console.warn(`Could not resolve ${hostname} to IP address`);\n      return null;\n    }\n\n    // Create a new candidate with the hostname replaced by the IP\n    const resolvedCandidateString = candidate.candidate.replace(hostname, ip);\n    \n    return {\n      ...candidate,\n      candidate: resolvedCandidateString,\n      address: ip\n    };\n  }\n\n  /**\n   * Clear the resolution cache\n   */\n  clearCache() {\n    this._cache.clear();\n  }\n\n  /**\n   * Dispose of the resolver and clean up resources\n   */\n  dispose() {\n    this.clearCache();\n    \n    // Clean up Node.js resolver if running\n    if (this._mode === 'node' && this._resolver) {\n      try {\n        this._resolver.stop();\n      } catch (error) {\n        console.warn('Error stopping mDNS resolver:', error.message);\n      }\n    }\n    \n    this._resolver = null;\n    this._initialized = false;\n    this._mode = null;\n  }\n}\n", "import { MDNSResolver } from './MDNSResolver.js';\n\n/**\n * Managed peer connection with built-in signaling support\n */\nexport class PeerConnection extends EventTarget {\n  constructor(rtcInstance, signalingClient, config = {}) {\n    super();\n    this.rtc = rtcInstance;\n    this.signaling = signalingClient;\n    this.config = config;\n    this.pc = null;\n    this.dataChannels = new Map();\n    this.remoteId = null;\n    this.isInitiator = false;\n    this.mdnsResolver = new MDNSResolver({\n      serverUrl: config.mdnsServerUrl || 'http://localhost:5380'\n    });\n    this._mdnsEnabled = config.enableMDNS !== false; // enabled by default\n  }\n\n  /**\n   * Initialize peer connection\n   * @private\n   */\n  async _init() {\n    // Initialize mDNS resolver if enabled\n    if (this._mdnsEnabled) {\n      await this.mdnsResolver.initialize();\n    }\n\n    this.pc = this.rtc.createPeerConnection(this.config);\n    \n    // Handle ICE candidates\n    this.pc.onicecandidate = async (event) => {\n      if (event.candidate && this.remoteId) {\n        let candidateToSend = event.candidate;\n        \n        // Try to resolve .local candidates if mDNS is enabled\n        if (this._mdnsEnabled && this.mdnsResolver.isAvailable() && \n            this.mdnsResolver.isLocalCandidate(event.candidate)) {\n          const resolvedCandidate = await this.mdnsResolver.resolveCandidate(event.candidate);\n          if (resolvedCandidate) {\n            candidateToSend = resolvedCandidate;\n            console.log('Resolved .local ICE candidate:', event.candidate.candidate, '->', resolvedCandidate.candidate);\n          }\n        }\n        \n        this.signaling.sendIceCandidate(this.remoteId, candidateToSend);\n      }\n    };\n    \n    // Handle connection state changes\n    this.pc.onconnectionstatechange = () => {\n      this.dispatchEvent(new CustomEvent('connectionstatechange', {\n        detail: this.pc.connectionState\n      }));\n      \n      if (this.pc.connectionState === 'connected') {\n        this.dispatchEvent(new CustomEvent('connected'));\n      } else if (this.pc.connectionState === 'failed') {\n        this.dispatchEvent(new CustomEvent('failed'));\n      }\n    };\n    \n    // Handle ICE connection state changes\n    this.pc.oniceconnectionstatechange = () => {\n      this.dispatchEvent(new CustomEvent('iceconnectionstatechange', {\n        detail: this.pc.iceConnectionState\n      }));\n    };\n    \n    // Handle remote tracks\n    this.pc.ontrack = (event) => {\n      this.dispatchEvent(new CustomEvent('track', {\n        detail: { track: event.track, streams: event.streams }\n      }));\n    };\n    \n    // Handle incoming data channels\n    this.pc.ondatachannel = (event) => {\n      const channel = event.channel;\n      this.dataChannels.set(channel.label, channel);\n      this._setupDataChannel(channel);\n      \n      this.dispatchEvent(new CustomEvent('datachannel', {\n        detail: channel\n      }));\n    };\n  }\n\n  /**\n   * Connect to a remote peer\n   * @param {string|number} peerId - Remote peer ID\n   * @param {MediaStream} [localStream] - Optional local media stream\n   * @returns {Promise<void>}\n   */\n  async connect(peerId, localStream = null) {\n    this.remoteId = peerId;\n    this.isInitiator = true;\n    await this._init();\n    \n    // Add local tracks if provided\n    if (localStream) {\n      localStream.getTracks().forEach(track => {\n        this.pc.addTrack(track, localStream);\n      });\n    }\n    \n    // Create and send offer\n    const offer = await this.pc.createOffer();\n    await this.pc.setLocalDescription(offer);\n    this.signaling.sendOffer(peerId, offer);\n  }\n\n  /**\n   * Handle incoming offer from remote peer\n   * @param {string|number} peerId - Remote peer ID\n   * @param {RTCSessionDescriptionInit} offer - WebRTC offer\n   * @param {MediaStream} [localStream] - Optional local media stream\n   * @returns {Promise<void>}\n   */\n  async handleOffer(peerId, offer, localStream = null) {\n    this.remoteId = peerId;\n    this.isInitiator = false;\n    await this._init();\n    \n    // Add local tracks if provided\n    if (localStream) {\n      localStream.getTracks().forEach(track => {\n        this.pc.addTrack(track, localStream);\n      });\n    }\n    \n    // Set remote description and create answer\n    await this.pc.setRemoteDescription(offer);\n    const answer = await this.pc.createAnswer();\n    await this.pc.setLocalDescription(answer);\n    this.signaling.sendAnswer(peerId, answer);\n  }\n\n  /**\n   * Handle incoming answer from remote peer\n   * @param {RTCSessionDescriptionInit} answer - WebRTC answer\n   * @returns {Promise<void>}\n   */\n  async handleAnswer(answer) {\n    await this.pc.setRemoteDescription(answer);\n  }\n\n  /**\n   * Handle incoming ICE candidate\n   * @param {RTCIceCandidateInit} candidate - ICE candidate\n   * @returns {Promise<void>}\n   */\n  async handleIceCandidate(candidate) {\n    if (this.pc) {\n      let candidateToAdd = candidate;\n      \n      // Try to resolve .local candidates if mDNS is enabled\n      if (this._mdnsEnabled && this.mdnsResolver.isAvailable() && \n          this.mdnsResolver.isLocalCandidate(candidate)) {\n        const resolvedCandidate = await this.mdnsResolver.resolveCandidate(candidate);\n        if (resolvedCandidate) {\n          candidateToAdd = resolvedCandidate;\n          console.log('Resolved incoming .local ICE candidate:', candidate.candidate, '->', resolvedCandidate.candidate);\n        }\n      }\n      \n      await this.pc.addIceCandidate(candidateToAdd);\n    }\n  }\n\n  /**\n   * Create a data channel\n   * @param {string} label - Channel label\n   * @param {RTCDataChannelInit} [options] - Data channel options\n   * @returns {RTCDataChannel}\n   */\n  createDataChannel(label, options = {}) {\n    if (!this.pc) {\n      throw new Error('Peer connection not initialized');\n    }\n    \n    const channel = this.pc.createDataChannel(label, options);\n    this.dataChannels.set(label, channel);\n    this._setupDataChannel(channel);\n    return channel;\n  }\n\n  /**\n   * Setup data channel event handlers\n   * @private\n   */\n  _setupDataChannel(channel) {\n    channel.onopen = () => {\n      this.dispatchEvent(new CustomEvent('channelopen', {\n        detail: channel\n      }));\n    };\n    \n    channel.onmessage = (event) => {\n      this.dispatchEvent(new CustomEvent('message', {\n        detail: { channel: channel.label, data: event.data }\n      }));\n    };\n    \n    channel.onclose = () => {\n      this.dataChannels.delete(channel.label);\n      this.dispatchEvent(new CustomEvent('channelclose', {\n        detail: channel\n      }));\n    };\n  }\n\n  /**\n   * Send data on a channel\n   * @param {string} channelLabel - Channel label\n   * @param {string|ArrayBuffer|Blob} data - Data to send\n   */\n  send(channelLabel, data) {\n    const channel = this.dataChannels.get(channelLabel);\n    if (channel && channel.readyState === 'open') {\n      channel.send(data);\n    } else {\n      throw new Error(`Channel ${channelLabel} not open`);\n    }\n  }\n\n  /**\n   * Get a data channel by label\n   * @param {string} label - Channel label\n   * @returns {RTCDataChannel|undefined}\n   */\n  getDataChannel(label) {\n    return this.dataChannels.get(label);\n  }\n\n  /**\n   * Get the underlying RTCPeerConnection\n   * @returns {RTCPeerConnection}\n   */\n  getRTCPeerConnection() {\n    return this.pc;\n  }\n\n  /**\n   * Close the peer connection\n   */\n  close() {\n    if (this.pc) {\n      this.pc.close();\n      this.pc = null;\n    }\n    this.dataChannels.clear();\n    this.remoteId = null;\n    \n    // Clean up mDNS resolver\n    if (this.mdnsResolver) {\n      this.mdnsResolver.dispose();\n    }\n  }\n}\n", "import { BrowserRTCAdapter } from './BrowserRTCAdapter.js';\nimport { NodeRTCAdapter } from './NodeRTCAdapter.js';\nimport { SignalingClient } from './SignalingClient.js';\nimport { PeerConnection } from './PeerConnection.js';\n\n/**\n * Main PigeonRTC class that provides a unified interface for WebRTC\n * across different environments with pluggable adapter support.\n */\nexport class PigeonRTC {\n  constructor(options = {}) {\n    this.adapter = options.adapter || null;\n    this.initialized = false;\n  }\n\n  /**\n   * Initialize PigeonRTC with automatic adapter detection or custom adapter\n   * @param {Object} options - Configuration options\n   * @param {RTCAdapter} options.adapter - Custom adapter to use (optional)\n   * @param {boolean} options.preferNode - Prefer Node adapter even in browser (for testing)\n   * @returns {Promise<void>}\n   */\n  async initialize(options = {}) {\n    if (this.initialized) {\n      return;\n    }\n\n    // Use custom adapter if provided\n    if (options.adapter) {\n      this.adapter = options.adapter;\n    }\n\n    // Auto-detect adapter if not provided\n    if (!this.adapter) {\n      this.adapter = await this._detectAdapter(options);\n    }\n\n    // Initialize the adapter\n    await this.adapter.initialize();\n    this.initialized = true;\n  }\n\n  /**\n   * Automatically detect and create the appropriate adapter for the current environment\n   * @private\n   */\n  async _detectAdapter(options = {}) {\n    // Try Node adapter first if we're in Node.js and preferNode is true or no browser support\n    if (options.preferNode || (typeof window === 'undefined' && typeof process !== 'undefined')) {\n      const nodeAdapter = new NodeRTCAdapter();\n      if (nodeAdapter.isSupported()) {\n        try {\n          await nodeAdapter.initialize();\n          return nodeAdapter;\n        } catch (error) {\n          // If Node adapter fails, fall through to browser adapter (might be in a hybrid environment)\n          console.warn('Node adapter initialization failed, trying browser adapter:', error.message);\n        }\n      }\n    }\n\n    // Try browser adapter\n    const browserAdapter = new BrowserRTCAdapter();\n    if (browserAdapter.isSupported()) {\n      return browserAdapter;\n    }\n\n    // No supported adapter found\n    throw new Error(\n      'No supported WebRTC adapter found. ' +\n      'Make sure you are running in a browser with WebRTC support or have @koush/wrtc installed for Node.js.'\n    );\n  }\n\n  /**\n   * Ensure PigeonRTC is initialized before use\n   * @private\n   */\n  _ensureInitialized() {\n    if (!this.initialized || !this.adapter) {\n      throw new Error('PigeonRTC not initialized. Call initialize() first.');\n    }\n  }\n\n  /**\n   * Get the RTCPeerConnection class\n   * @returns {typeof RTCPeerConnection}\n   */\n  getRTCPeerConnection() {\n    this._ensureInitialized();\n    return this.adapter.getRTCPeerConnection();\n  }\n\n  /**\n   * Get the RTCSessionDescription class\n   * @returns {typeof RTCSessionDescription}\n   */\n  getRTCSessionDescription() {\n    this._ensureInitialized();\n    return this.adapter.getRTCSessionDescription();\n  }\n\n  /**\n   * Get the RTCIceCandidate class\n   * @returns {typeof RTCIceCandidate}\n   */\n  getRTCIceCandidate() {\n    this._ensureInitialized();\n    return this.adapter.getRTCIceCandidate();\n  }\n\n  /**\n   * Get the MediaStream class (if supported)\n   * @returns {typeof MediaStream|null}\n   */\n  getMediaStream() {\n    this._ensureInitialized();\n    return this.adapter.getMediaStream();\n  }\n\n  /**\n   * Create a new RTCPeerConnection with the given configuration\n   * @param {RTCConfiguration} config - RTCPeerConnection configuration\n   * @returns {RTCPeerConnection}\n   */\n  createPeerConnection(config) {\n    this._ensureInitialized();\n    const RTCPeerConnection = this.adapter.getRTCPeerConnection();\n    return new RTCPeerConnection(config);\n  }\n\n  /**\n   * Create a new RTCSessionDescription\n   * @param {RTCSessionDescriptionInit} init - Session description initialization\n   * @returns {RTCSessionDescription}\n   */\n  createSessionDescription(init) {\n    this._ensureInitialized();\n    const RTCSessionDescription = this.adapter.getRTCSessionDescription();\n    return new RTCSessionDescription(init);\n  }\n\n  /**\n   * Create a new RTCIceCandidate\n   * @param {RTCIceCandidateInit} init - ICE candidate initialization\n   * @returns {RTCIceCandidate}\n   */\n  createIceCandidate(init) {\n    this._ensureInitialized();\n    const RTCIceCandidate = this.adapter.getRTCIceCandidate();\n    return new RTCIceCandidate(init);\n  }\n\n  /**\n   * Get user media stream (camera/microphone)\n   * @param {MediaStreamConstraints} constraints\n   * @returns {Promise<MediaStream>}\n   */\n  async getUserMedia(constraints) {\n    this._ensureInitialized();\n    return await this.adapter.getUserMedia(constraints);\n  }\n\n  /**\n   * Get display media stream (screen sharing)\n   * @param {MediaStreamConstraints} constraints\n   * @returns {Promise<MediaStream>}\n   */\n  async getDisplayMedia(constraints) {\n    this._ensureInitialized();\n    return await this.adapter.getDisplayMedia(constraints);\n  }\n\n  /**\n   * Check if WebRTC is supported in the current environment\n   * @returns {boolean}\n   */\n  isSupported() {\n    return this.adapter ? this.adapter.isSupported() : false;\n  }\n\n  /**\n   * Get the name of the current adapter\n   * @returns {string}\n   */\n  getAdapterName() {\n    return this.adapter ? this.adapter.getName() : 'None';\n  }\n\n  /**\n   * Create a signaling client for peer discovery and connection management\n   * @param {string} serverUrl - WebSocket server URL (e.g., 'ws://localhost:9090')\n   * @returns {SignalingClient}\n   */\n  createSignalingClient(serverUrl) {\n    return new SignalingClient(serverUrl);\n  }\n\n  /**\n   * Create a managed peer connection with built-in signaling\n   * @param {SignalingClient} signalingClient - Signaling client instance\n   * @param {RTCConfiguration} config - RTCPeerConnection configuration\n   * @returns {PeerConnection}\n   */\n  createManagedPeerConnection(signalingClient, config = {}) {\n    this._ensureInitialized();\n    return new PeerConnection(this, signalingClient, config);\n  }\n}\n\n/**\n * Create and initialize a PigeonRTC instance\n * @param {Object} options - Configuration options\n * @returns {Promise<PigeonRTC>}\n */\nexport async function createPigeonRTC(options = {}) {\n  const rtc = new PigeonRTC(options);\n  await rtc.initialize(options);\n  return rtc;\n}\n\n// Export additional classes\nexport { SignalingClient } from './SignalingClient.js';\nexport { PeerConnection } from './PeerConnection.js';\n"],
  "mappings": "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",
  "names": ["index_exports", "__export", "BrowserRTCAdapter", "MDNSResolver", "NodeRTCAdapter", "PeerConnection", "PigeonRTC", "RTCAdapter", "SignalingClient", "createPigeonRTC", "index_default", "RTCAdapter", "_constraints", "BrowserRTCAdapter", "RTCAdapter", "constraints", "getUserMedia", "resolve", "reject", "NodeRTCAdapter", "RTCAdapter", "wrtcModule", "_constraints", "SignalingClient", "serverUrl", "resolve", "reject", "event", "message", "err", "error", "peerId", "offer", "answer", "candidate", "MDNSResolver", "options", "pigeonnsModule", "error", "candidate", "candidateString", "parts", "hostname", "cached", "ip", "cachedIP", "response", "resolvedCandidateString", "PeerConnection", "rtcInstance", "signalingClient", "config", "MDNSResolver", "event", "candidateToSend", "resolvedCandidate", "channel", "peerId", "localStream", "track", "offer", "answer", "candidate", "candidateToAdd", "label", "options", "channelLabel", "data", "PigeonRTC", "options", "nodeAdapter", "NodeRTCAdapter", "error", "browserAdapter", "BrowserRTCAdapter", "config", "RTCPeerConnection", "init", "RTCSessionDescription", "RTCIceCandidate", "constraints", "serverUrl", "SignalingClient", "signalingClient", "PeerConnection", "createPigeonRTC", "rtc", "index_default", "createPigeonRTC"]
}
