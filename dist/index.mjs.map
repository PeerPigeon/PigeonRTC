{
  "version": 3,
  "sources": ["../src/RTCAdapter.js", "../src/BrowserRTCAdapter.js", "../src/NodeRTCAdapter.js", "../src/PigeonRTC.js", "../src/index.js"],
  "sourcesContent": ["/**\n * Base RTCAdapter interface that all WebRTC adapters must implement.\n * This provides a consistent API regardless of the underlying WebRTC implementation.\n */\nexport class RTCAdapter {\n  /**\n   * Get the RTCPeerConnection class for this adapter\n   * @returns {typeof RTCPeerConnection} The RTCPeerConnection class\n   */\n  getRTCPeerConnection() {\n    throw new Error('getRTCPeerConnection must be implemented by adapter');\n  }\n\n  /**\n   * Get the RTCSessionDescription class for this adapter\n   * @returns {typeof RTCSessionDescription} The RTCSessionDescription class\n   */\n  getRTCSessionDescription() {\n    throw new Error('getRTCSessionDescription must be implemented by adapter');\n  }\n\n  /**\n   * Get the RTCIceCandidate class for this adapter\n   * @returns {typeof RTCIceCandidate} The RTCIceCandidate class\n   */\n  getRTCIceCandidate() {\n    throw new Error('getRTCIceCandidate must be implemented by adapter');\n  }\n\n  /**\n   * Get the MediaStream class for this adapter (if supported)\n   * @returns {typeof MediaStream|null} The MediaStream class or null if not supported\n   */\n  getMediaStream() {\n    return null;\n  }\n\n  /**\n   * Check if this adapter supports the current environment\n   * @returns {boolean} True if the adapter can work in the current environment\n   */\n  isSupported() {\n    throw new Error('isSupported must be implemented by adapter');\n  }\n\n  /**\n   * Get the name of this adapter\n   * @returns {string} The adapter name\n   */\n  getName() {\n    throw new Error('getName must be implemented by adapter');\n  }\n\n  /**\n   * Initialize the adapter (for any setup that needs to happen)\n   * @returns {Promise<void>}\n   */\n  async initialize() {\n    // Default implementation does nothing\n  }\n\n  /**\n   * Get user media (if supported)\n   * @param {MediaStreamConstraints} constraints\n   * @returns {Promise<MediaStream>}\n   */\n  async getUserMedia(constraints) {\n    throw new Error('getUserMedia not supported by this adapter');\n  }\n\n  /**\n   * Get display media (if supported)\n   * @param {MediaStreamConstraints} constraints\n   * @returns {Promise<MediaStream>}\n   */\n  async getDisplayMedia(constraints) {\n    throw new Error('getDisplayMedia not supported by this adapter');\n  }\n}\n", "import { RTCAdapter } from './RTCAdapter.js';\n\n/**\n * Browser-native WebRTC adapter for use in web browsers.\n * This adapter uses the browser's native WebRTC implementation.\n */\nexport class BrowserRTCAdapter extends RTCAdapter {\n  constructor() {\n    super();\n    this._checkSupport();\n  }\n\n  _checkSupport() {\n    // Check if we're in a browser environment\n    if (typeof window === 'undefined' || typeof navigator === 'undefined') {\n      return;\n    }\n\n    // Browser environment - check for WebRTC support\n    this.hasRTCPeerConnection = !!(\n      window.RTCPeerConnection ||\n      window.webkitRTCPeerConnection ||\n      window.mozRTCPeerConnection\n    );\n\n    this.hasGetUserMedia = !!(\n      navigator.mediaDevices?.getUserMedia ||\n      navigator.getUserMedia ||\n      navigator.webkitGetUserMedia ||\n      navigator.mozGetUserMedia\n    );\n\n    this.hasGetDisplayMedia = !!(\n      navigator.mediaDevices?.getDisplayMedia\n    );\n  }\n\n  getRTCPeerConnection() {\n    if (typeof window === 'undefined') {\n      throw new Error('BrowserRTCAdapter requires a browser environment');\n    }\n\n    return window.RTCPeerConnection ||\n           window.webkitRTCPeerConnection ||\n           window.mozRTCPeerConnection;\n  }\n\n  getRTCSessionDescription() {\n    if (typeof window === 'undefined') {\n      throw new Error('BrowserRTCAdapter requires a browser environment');\n    }\n\n    return window.RTCSessionDescription ||\n           window.mozRTCSessionDescription;\n  }\n\n  getRTCIceCandidate() {\n    if (typeof window === 'undefined') {\n      throw new Error('BrowserRTCAdapter requires a browser environment');\n    }\n\n    return window.RTCIceCandidate ||\n           window.mozRTCIceCandidate;\n  }\n\n  getMediaStream() {\n    if (typeof window === 'undefined') {\n      return null;\n    }\n\n    return window.MediaStream || window.webkitMediaStream;\n  }\n\n  isSupported() {\n    return typeof window !== 'undefined' && this.hasRTCPeerConnection;\n  }\n\n  getName() {\n    return 'BrowserRTCAdapter';\n  }\n\n  async getUserMedia(constraints) {\n    if (typeof navigator === 'undefined') {\n      throw new Error('getUserMedia requires a browser environment');\n    }\n\n    // Modern API\n    if (navigator.mediaDevices?.getUserMedia) {\n      return await navigator.mediaDevices.getUserMedia(constraints);\n    }\n\n    // Legacy API with Promise wrapper\n    const getUserMedia = navigator.getUserMedia ||\n                        navigator.webkitGetUserMedia ||\n                        navigator.mozGetUserMedia;\n\n    if (!getUserMedia) {\n      throw new Error('getUserMedia is not supported in this browser');\n    }\n\n    return new Promise((resolve, reject) => {\n      getUserMedia.call(navigator, constraints, resolve, reject);\n    });\n  }\n\n  async getDisplayMedia(constraints) {\n    if (typeof navigator === 'undefined') {\n      throw new Error('getDisplayMedia requires a browser environment');\n    }\n\n    if (!navigator.mediaDevices?.getDisplayMedia) {\n      throw new Error('getDisplayMedia is not supported in this browser');\n    }\n\n    return await navigator.mediaDevices.getDisplayMedia(constraints);\n  }\n}\n", "import { RTCAdapter } from './RTCAdapter.js';\n\n/**\n * Node.js WebRTC adapter using @koush/wrtc package.\n * This adapter provides WebRTC functionality in Node.js environments.\n */\nexport class NodeRTCAdapter extends RTCAdapter {\n  constructor() {\n    super();\n    this._wrtc = null;\n    this._initialized = false;\n  }\n\n  async initialize() {\n    if (this._initialized) {\n      return;\n    }\n\n    try {\n      // Dynamically import @koush/wrtc (it's an optional peer dependency)\n      const wrtc = await import('@koush/wrtc');\n      this._wrtc = wrtc;\n      this._initialized = true;\n    } catch (error) {\n      throw new Error(\n        'NodeRTCAdapter requires @koush/wrtc to be installed. ' +\n        'Install it with: npm install @koush/wrtc'\n      );\n    }\n  }\n\n  _ensureInitialized() {\n    if (!this._initialized || !this._wrtc) {\n      throw new Error(\n        'NodeRTCAdapter not initialized. Call initialize() first.'\n      );\n    }\n  }\n\n  getRTCPeerConnection() {\n    this._ensureInitialized();\n    return this._wrtc.RTCPeerConnection;\n  }\n\n  getRTCSessionDescription() {\n    this._ensureInitialized();\n    return this._wrtc.RTCSessionDescription;\n  }\n\n  getRTCIceCandidate() {\n    this._ensureInitialized();\n    return this._wrtc.RTCIceCandidate;\n  }\n\n  getMediaStream() {\n    this._ensureInitialized();\n    return this._wrtc.MediaStream || null;\n  }\n\n  isSupported() {\n    // Check if we're in a Node.js environment (not browser)\n    return typeof process !== 'undefined' &&\n           process.versions != null &&\n           process.versions.node != null &&\n           typeof window === 'undefined';\n  }\n\n  getName() {\n    return 'NodeRTCAdapter';\n  }\n\n  async getUserMedia(constraints) {\n    // Node.js doesn't typically support getUserMedia\n    // This would require additional hardware access libraries\n    throw new Error('getUserMedia is not supported in Node.js environment');\n  }\n\n  async getDisplayMedia(constraints) {\n    // Node.js doesn't support getDisplayMedia\n    throw new Error('getDisplayMedia is not supported in Node.js environment');\n  }\n}\n", "import { BrowserRTCAdapter } from './BrowserRTCAdapter.js';\nimport { NodeRTCAdapter } from './NodeRTCAdapter.js';\n\n/**\n * Main PigeonRTC class that provides a unified interface for WebRTC\n * across different environments with pluggable adapter support.\n */\nexport class PigeonRTC {\n  constructor(options = {}) {\n    this.adapter = options.adapter || null;\n    this.initialized = false;\n  }\n\n  /**\n   * Initialize PigeonRTC with automatic adapter detection or custom adapter\n   * @param {Object} options - Configuration options\n   * @param {RTCAdapter} options.adapter - Custom adapter to use (optional)\n   * @param {boolean} options.preferNode - Prefer Node adapter even in browser (for testing)\n   * @returns {Promise<void>}\n   */\n  async initialize(options = {}) {\n    if (this.initialized) {\n      return;\n    }\n\n    // Use custom adapter if provided\n    if (options.adapter) {\n      this.adapter = options.adapter;\n    }\n\n    // Auto-detect adapter if not provided\n    if (!this.adapter) {\n      this.adapter = await this._detectAdapter(options);\n    }\n\n    // Initialize the adapter\n    await this.adapter.initialize();\n    this.initialized = true;\n  }\n\n  /**\n   * Automatically detect and create the appropriate adapter for the current environment\n   * @private\n   */\n  async _detectAdapter(options = {}) {\n    // Try Node adapter first if we're in Node.js and preferNode is true or no browser support\n    if (options.preferNode || (typeof window === 'undefined' && typeof process !== 'undefined')) {\n      const nodeAdapter = new NodeRTCAdapter();\n      if (nodeAdapter.isSupported()) {\n        try {\n          await nodeAdapter.initialize();\n          return nodeAdapter;\n        } catch (error) {\n          // If Node adapter fails, fall through to browser adapter (might be in a hybrid environment)\n          console.warn('Node adapter initialization failed, trying browser adapter:', error.message);\n        }\n      }\n    }\n\n    // Try browser adapter\n    const browserAdapter = new BrowserRTCAdapter();\n    if (browserAdapter.isSupported()) {\n      return browserAdapter;\n    }\n\n    // No supported adapter found\n    throw new Error(\n      'No supported WebRTC adapter found. ' +\n      'Make sure you are running in a browser with WebRTC support or have @koush/wrtc installed for Node.js.'\n    );\n  }\n\n  /**\n   * Ensure PigeonRTC is initialized before use\n   * @private\n   */\n  _ensureInitialized() {\n    if (!this.initialized || !this.adapter) {\n      throw new Error('PigeonRTC not initialized. Call initialize() first.');\n    }\n  }\n\n  /**\n   * Get the RTCPeerConnection class\n   * @returns {typeof RTCPeerConnection}\n   */\n  getRTCPeerConnection() {\n    this._ensureInitialized();\n    return this.adapter.getRTCPeerConnection();\n  }\n\n  /**\n   * Get the RTCSessionDescription class\n   * @returns {typeof RTCSessionDescription}\n   */\n  getRTCSessionDescription() {\n    this._ensureInitialized();\n    return this.adapter.getRTCSessionDescription();\n  }\n\n  /**\n   * Get the RTCIceCandidate class\n   * @returns {typeof RTCIceCandidate}\n   */\n  getRTCIceCandidate() {\n    this._ensureInitialized();\n    return this.adapter.getRTCIceCandidate();\n  }\n\n  /**\n   * Get the MediaStream class (if supported)\n   * @returns {typeof MediaStream|null}\n   */\n  getMediaStream() {\n    this._ensureInitialized();\n    return this.adapter.getMediaStream();\n  }\n\n  /**\n   * Create a new RTCPeerConnection with the given configuration\n   * @param {RTCConfiguration} config - RTCPeerConnection configuration\n   * @returns {RTCPeerConnection}\n   */\n  createPeerConnection(config) {\n    this._ensureInitialized();\n    const RTCPeerConnection = this.adapter.getRTCPeerConnection();\n    return new RTCPeerConnection(config);\n  }\n\n  /**\n   * Create a new RTCSessionDescription\n   * @param {RTCSessionDescriptionInit} init - Session description initialization\n   * @returns {RTCSessionDescription}\n   */\n  createSessionDescription(init) {\n    this._ensureInitialized();\n    const RTCSessionDescription = this.adapter.getRTCSessionDescription();\n    return new RTCSessionDescription(init);\n  }\n\n  /**\n   * Create a new RTCIceCandidate\n   * @param {RTCIceCandidateInit} init - ICE candidate initialization\n   * @returns {RTCIceCandidate}\n   */\n  createIceCandidate(init) {\n    this._ensureInitialized();\n    const RTCIceCandidate = this.adapter.getRTCIceCandidate();\n    return new RTCIceCandidate(init);\n  }\n\n  /**\n   * Get user media stream (camera/microphone)\n   * @param {MediaStreamConstraints} constraints\n   * @returns {Promise<MediaStream>}\n   */\n  async getUserMedia(constraints) {\n    this._ensureInitialized();\n    return await this.adapter.getUserMedia(constraints);\n  }\n\n  /**\n   * Get display media stream (screen sharing)\n   * @param {MediaStreamConstraints} constraints\n   * @returns {Promise<MediaStream>}\n   */\n  async getDisplayMedia(constraints) {\n    this._ensureInitialized();\n    return await this.adapter.getDisplayMedia(constraints);\n  }\n\n  /**\n   * Check if WebRTC is supported in the current environment\n   * @returns {boolean}\n   */\n  isSupported() {\n    return this.adapter ? this.adapter.isSupported() : false;\n  }\n\n  /**\n   * Get the name of the current adapter\n   * @returns {string}\n   */\n  getAdapterName() {\n    return this.adapter ? this.adapter.getName() : 'None';\n  }\n}\n\n/**\n * Create and initialize a PigeonRTC instance\n * @param {Object} options - Configuration options\n * @returns {Promise<PigeonRTC>}\n */\nexport async function createPigeonRTC(options = {}) {\n  const rtc = new PigeonRTC(options);\n  await rtc.initialize(options);\n  return rtc;\n}\n", "/**\n * PigeonRTC - Pluggable cross-browser compatible WebRTC library\n * \n * A lightweight, pluggable WebRTC library that provides a consistent API\n * across different environments (browser and Node.js) with support for\n * custom adapters.\n * \n * @module pigeonrtc\n */\n\nexport { PigeonRTC, createPigeonRTC } from './PigeonRTC.js';\nexport { RTCAdapter } from './RTCAdapter.js';\nexport { BrowserRTCAdapter } from './BrowserRTCAdapter.js';\nexport { NodeRTCAdapter } from './NodeRTCAdapter.js';\n\n// Default export for convenience\nimport { createPigeonRTC } from './PigeonRTC.js';\nexport default createPigeonRTC;\n"],
  "mappings": "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",
  "names": []
}
