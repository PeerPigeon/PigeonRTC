<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>PigeonRTC Browser Example</title>
  <style>
    body {
      font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
      max-width: 900px;
      margin: 50px auto;
      padding: 20px;
      background-color: #f5f5f5;
    }
    .container {
      background: white;
      padding: 30px;
      border-radius: 8px;
      box-shadow: 0 2px 10px rgba(0,0,0,0.1);
    }
    h1 {
      color: #333;
      margin-bottom: 10px;
    }
    .subtitle {
      color: #666;
      margin-bottom: 30px;
    }
    button {
      background-color: #4CAF50;
      color: white;
      padding: 12px 24px;
      border: none;
      border-radius: 4px;
      cursor: pointer;
      font-size: 16px;
      margin: 5px;
    }
    button:hover {
      background-color: #45a049;
    }
    button:disabled {
      background-color: #cccccc;
      cursor: not-allowed;
    }
    .status {
      margin-top: 20px;
      padding: 15px;
      background-color: #e8f5e9;
      border-left: 4px solid #4CAF50;
      border-radius: 4px;
    }
    .error {
      background-color: #ffebee;
      border-left-color: #f44336;
    }
    .log {
      margin-top: 20px;
      padding: 15px;
      background-color: #f5f5f5;
      border-radius: 4px;
      max-height: 400px;
      overflow-y: auto;
      font-family: 'Courier New', monospace;
      font-size: 14px;
    }
    .log-entry {
      margin: 5px 0;
      padding: 5px;
      border-left: 3px solid #2196F3;
      padding-left: 10px;
    }
    .info-section {
      margin: 20px 0;
      padding: 15px;
      background-color: #e3f2fd;
      border-radius: 4px;
    }
  </style>
</head>
<body>
  <div class="container">
    <h1>üïäÔ∏è PigeonRTC Browser Example</h1>
    <p class="subtitle">Cross-browser compatible WebRTC library demo</p>

    <div class="info-section">
      <h3>Library Info</h3>
      <div id="libInfo">Initializing...</div>
      <p style="margin-top: 10px; font-size: 13px; color: #666;">
        <strong>Note:</strong> Local loopback connections (PC1 ‚Üî PC2 in the same tab) may fail in Chrome due to mDNS candidate limitations.
        This is a Chrome testing limitation, not a PigeonRTC issue. Real-world connections between different devices/browsers work perfectly!
      </p>
    </div>

    <div>
      <button id="initBtn" onclick="initializeRTC()">Initialize PigeonRTC</button>
      <button id="createPCBtn" onclick="createPeerConnection()" disabled>Create Peer Connection</button>
      <button id="testConnectionBtn" onclick="testConnection()" disabled>Test Local Connection</button>
      <button id="testAPIBtn" onclick="testAPI()" disabled style="background-color: #9C27B0;">Test API Only</button>
      <button id="testNativeBtn" onclick="testNativeConnection()" style="background-color: #2196F3;">Test Native WebRTC</button>
      <button id="clearBtn" onclick="clearLog()">Clear Log</button>
    </div>

    <div id="status" class="status" style="display: none;"></div>

    <div class="log" id="logContainer">
      <div class="log-entry">Log output will appear here...</div>
    </div>
  </div>

  <script type="module">
    // Import PigeonRTC from the built browser bundle
    import { createPigeonRTC } from '../dist/index.mjs';

    let rtc = null;
    let peerConnection = null;

    function log(message, type = 'info') {
      const logContainer = document.getElementById('logContainer');
      const entry = document.createElement('div');
      entry.className = 'log-entry';
      entry.textContent = `[${new Date().toLocaleTimeString()}] ${message}`;
      
      if (type === 'error') {
        entry.style.borderLeftColor = '#f44336';
      } else if (type === 'success') {
        entry.style.borderLeftColor = '#4CAF50';
      }
      
      logContainer.appendChild(entry);
      logContainer.scrollTop = logContainer.scrollHeight;
    }

    function showStatus(message, isError = false) {
      const status = document.getElementById('status');
      status.textContent = message;
      status.className = isError ? 'status error' : 'status';
      status.style.display = 'block';
    }

    window.initializeRTC = async function() {
      try {
        log('Initializing PigeonRTC...', 'info');
        document.getElementById('initBtn').disabled = true;
        
        rtc = await createPigeonRTC();
        
        const adapterName = rtc.getAdapterName();
        const isSupported = rtc.isSupported();
        
        log(`Successfully initialized with ${adapterName}`, 'success');
        log(`WebRTC supported: ${isSupported}`, 'info');
        
        document.getElementById('libInfo').innerHTML = `
          <strong>Adapter:</strong> ${adapterName}<br>
          <strong>Supported:</strong> ${isSupported ? '‚úÖ Yes' : '‚ùå No'}<br>
          <strong>Status:</strong> Initialized
        `;
        
        if (isSupported) {
          document.getElementById('createPCBtn').disabled = false;
          document.getElementById('testAPIBtn').disabled = false;
          showStatus('PigeonRTC initialized successfully!');
        } else {
          showStatus('WebRTC is not supported in this environment', true);
        }
      } catch (error) {
        log(`Error initializing: ${error.message}`, 'error');
        showStatus(`Error: ${error.message}`, true);
      }
    };

    window.createPeerConnection = function() {
      try {
        log('Creating peer connection...', 'info');
        
        const config = {
          iceServers: [
            { urls: 'stun:stun.l.google.com:19302' },
            { urls: 'stun:stun1.l.google.com:19302' }
          ]
        };
        
        peerConnection = rtc.createPeerConnection(config);
        
        peerConnection.onicecandidate = (event) => {
          if (event.candidate) {
            log(`ICE candidate: ${event.candidate.type}`, 'info');
          }
        };
        
        peerConnection.onconnectionstatechange = () => {
          log(`Connection state: ${peerConnection.connectionState}`, 'info');
        };
        
        peerConnection.onicegatheringstatechange = () => {
          log(`ICE gathering state: ${peerConnection.iceGatheringState}`, 'info');
        };
        
        log('Peer connection created successfully', 'success');
        document.getElementById('testConnectionBtn').disabled = false;
        showStatus('Peer connection created!');
        
      } catch (error) {
        log(`Error creating peer connection: ${error.message}`, 'error');
        showStatus(`Error: ${error.message}`, true);
      }
    };

    window.testConnection = async function() {
      try {
        log('Testing local peer-to-peer connection...', 'info');
        document.getElementById('testConnectionBtn').disabled = true;
        
        // Create peer connections with STUN server to get real IP candidates
        const config = {
          iceServers: [{ urls: 'stun:stun.l.google.com:19302' }]
        };
        
        const pc1 = rtc.createPeerConnection(config);
        const pc2 = rtc.createPeerConnection(config);
        
        log('Created PC1 and PC2', 'info');
        
        // SET UP ALL EVENT HANDLERS FIRST - BEFORE SIGNALING
        pc1.oniceconnectionstatechange = () => {
          log(`PC1 ICE: ${pc1.iceConnectionState}`, 'info');
        };
        
        pc2.oniceconnectionstatechange = () => {
          log(`PC2 ICE: ${pc2.iceConnectionState}`, 'info');
        };
        
        pc1.onconnectionstatechange = () => {
          log(`PC1 connection: ${pc1.connectionState}`, 'info');
          if (pc1.connectionState === 'failed') {
            document.getElementById('testConnectionBtn').disabled = false;
          }
        };
        
        pc2.onconnectionstatechange = () => {
          log(`PC2 connection: ${pc2.connectionState}`, 'info');
        };
        
        // Exchange ICE candidates
        pc1.onicecandidate = (e) => {
          if (e.candidate) {
            log('PC1 ‚Üí PC2: ICE candidate', 'info');
            pc2.addIceCandidate(e.candidate).catch(err => {
              log(`PC2 addIceCandidate error: ${err.message}`, 'error');
            });
          } else {
            log('PC1: ICE gathering complete', 'info');
          }
        };
        
        pc2.onicecandidate = (e) => {
          if (e.candidate) {
            log('PC2 ‚Üí PC1: ICE candidate', 'info');
            pc1.addIceCandidate(e.candidate).catch(err => {
              log(`PC1 addIceCandidate error: ${err.message}`, 'error');
            });
          } else {
            log('PC2: ICE gathering complete', 'info');
          }
        };
        
        // Create data channel
        const dataChannel = pc1.createDataChannel('test', { ordered: true });
        
        dataChannel.onopen = () => {
          log('‚úÖ Data channel opened!', 'success');
          dataChannel.send('Hello from PC1!');
          showStatus('Test connection successful! Data channel is open.');
          document.getElementById('testConnectionBtn').disabled = false;
        };
        
        dataChannel.onmessage = (event) => {
          log(`PC1 received: ${event.data}`, 'success');
        };
        
        dataChannel.onerror = (error) => {
          log(`Data channel error: ${error}`, 'error');
        };
        
        dataChannel.onclose = () => {
          log('Data channel closed', 'info');
        };
        
        // Handle data channel on PC2
        pc2.ondatachannel = (event) => {
          const channel = event.channel;
          log('PC2 received data channel', 'info');
          
          channel.onopen = () => {
            log('PC2 data channel opened', 'success');
            channel.send('Hello from PC2!');
          };
          
          channel.onmessage = (event) => {
            log(`PC2 received: ${event.data}`, 'success');
          };
        };
        
        // Perfect negotiation pattern
        log('Creating offer...', 'info');
        const offer = await pc1.createOffer();
        log(`Offer created: ${offer.type}`, 'info');
        
        await pc1.setLocalDescription(offer);
        log('PC1 local description set', 'info');
        
        await pc2.setRemoteDescription(offer);
        log('PC2 remote description set', 'info');
        
        log('Creating answer...', 'info');
        const answer = await pc2.createAnswer();
        log(`Answer created: ${answer.type}`, 'info');
        
        await pc2.setLocalDescription(answer);
        log('PC2 local description set', 'info');
        
        await pc1.setRemoteDescription(answer);
        log('PC1 remote description set', 'info');
        
        log('Signaling complete, ICE negotiation in progress...', 'success');
        
      } catch (error) {
        log(`Error: ${error.message}`, 'error');
        console.error('Full error:', error);
        showStatus(`Error: ${error.message}`, true);
        document.getElementById('testConnectionBtn').disabled = false;
      }
    };

    window.clearLog = function() {
      document.getElementById('logContainer').innerHTML = '<div class="log-entry">Log cleared.</div>';
    };

    // Test PigeonRTC API without trying to establish connection
    window.testAPI = async function() {
      try {
        log('Testing PigeonRTC API...', 'info');
        document.getElementById('testAPIBtn').disabled = true;
        
        // Test creating peer connections
        const pc1 = rtc.createPeerConnection({ iceServers: [{ urls: 'stun:stun.l.google.com:19302' }] });
        const pc2 = rtc.createPeerConnection({ iceServers: [{ urls: 'stun:stun.l.google.com:19302' }] });
        log('‚úÖ Created two peer connections', 'success');
        
        // Test creating data channel
        const dc = pc1.createDataChannel('test');
        log('‚úÖ Created data channel', 'success');
        
        // Test creating offer
        const offer = await pc1.createOffer();
        log(`‚úÖ Created offer (type: ${offer.type})`, 'success');
        
        // Test setting local description
        await pc1.setLocalDescription(offer);
        log('‚úÖ Set local description on PC1', 'success');
        
        // Test setting remote description
        await pc2.setRemoteDescription(offer);
        log('‚úÖ Set remote description on PC2', 'success');
        
        // Test creating answer
        const answer = await pc2.createAnswer();
        log(`‚úÖ Created answer (type: ${answer.type})`, 'success');
        
        // Test setting local description
        await pc2.setLocalDescription(answer);
        log('‚úÖ Set local description on PC2', 'success');
        
        // Test setting remote description
        await pc1.setRemoteDescription(answer);
        log('‚úÖ Set remote description on PC1', 'success');
        
        // Test ICE candidate creation
        const candidateInit = { candidate: 'test', sdpMLineIndex: 0 };
        try {
          const iceCandidate = rtc.createIceCandidate(candidateInit);
          log('‚úÖ Created ICE candidate object', 'success');
        } catch (err) {
          log(`‚ö†Ô∏è ICE candidate creation: ${err.message}`, 'info');
        }
        
        // Test getting classes
        const RTCPeerConnection = rtc.getRTCPeerConnection();
        const RTCSessionDescription = rtc.getRTCSessionDescription();
        const RTCIceCandidate = rtc.getRTCIceCandidate();
        log(`‚úÖ Got RTCPeerConnection: ${typeof RTCPeerConnection}`, 'success');
        log(`‚úÖ Got RTCSessionDescription: ${typeof RTCSessionDescription}`, 'success');
        log(`‚úÖ Got RTCIceCandidate: ${typeof RTCIceCandidate}`, 'success');
        
        // Close connections
        pc1.close();
        pc2.close();
        log('‚úÖ Closed connections', 'success');
        
        log('üéâ ALL API TESTS PASSED! PigeonRTC is working correctly.', 'success');
        showStatus('All API tests passed! PigeonRTC is fully functional.');
        
        document.getElementById('testAPIBtn').disabled = false;
        
      } catch (error) {
        log(`‚ùå API Test failed: ${error.message}`, 'error');
        console.error('API test error:', error);
        showStatus(`API test failed: ${error.message}`, true);
        document.getElementById('testAPIBtn').disabled = false;
      }
    };

    // Test with native WebRTC (bypassing PigeonRTC)
    window.testNativeConnection = async function() {
      try {
        log('Testing with NATIVE WebRTC...', 'info');
        
        const pc1 = new RTCPeerConnection();
        const pc2 = new RTCPeerConnection();
        
        log('Native: Created PC1 and PC2', 'info');
        
        // Queue candidates
        const pc1Candidates = [];
        const pc2Candidates = [];
        
        // SET UP EVENT HANDLERS FIRST - BEFORE ANY SIGNALING
        pc1.oniceconnectionstatechange = () => {
          log(`Native PC1 ICE: ${pc1.iceConnectionState}`, 'info');
          if (pc1.iceConnectionState === 'connected' || pc1.iceConnectionState === 'completed') {
            log('‚úÖ Native PC1 connected!', 'success');
          }
        };
        
        pc2.oniceconnectionstatechange = () => {
          log(`Native PC2 ICE: ${pc2.iceConnectionState}`, 'info');
          if (pc2.iceConnectionState === 'connected' || pc2.iceConnectionState === 'completed') {
            log('‚úÖ Native PC2 connected!', 'success');
          }
        };
        
        pc1.onconnectionstatechange = () => {
          log(`Native PC1 connection: ${pc1.connectionState}`, 'info');
        };
        
        pc2.onconnectionstatechange = () => {
          log(`Native PC2 connection: ${pc2.connectionState}`, 'info');
        };
        
        // Queue candidates instead of adding immediately
        pc1.onicecandidate = async (e) => {
          if (e.candidate) {
            log(`Native PC1 ‚Üí PC2: ${e.candidate.candidate.substring(0, 50)}...`, 'info');
            pc2Candidates.push(e.candidate);
          } else {
            log('Native: PC1 ICE gathering done', 'info');
          }
        };
        
        pc2.onicecandidate = async (e) => {
          if (e.candidate) {
            log(`Native PC2 ‚Üí PC1: ${e.candidate.candidate.substring(0, 50)}...`, 'info');
            pc1Candidates.push(e.candidate);
          } else {
            log('Native: PC2 ICE gathering done', 'info');
          }
        };
        
        // Create data channel
        const dataChannel = pc1.createDataChannel('test');
        
        dataChannel.onopen = () => {
          log('‚úÖ Native: Data channel opened!', 'success');
          dataChannel.send('Hello from native PC1!');
        };
        
        dataChannel.onmessage = (event) => {
          log(`Native PC1 received: ${event.data}`, 'success');
        };
        
        pc2.ondatachannel = (event) => {
          const channel = event.channel;
          log('Native: PC2 received data channel', 'info');
          
          channel.onopen = () => {
            log('Native: PC2 data channel opened', 'success');
            channel.send('Hello from native PC2!');
          };
          
          channel.onmessage = (event) => {
            log(`Native PC2 received: ${event.data}`, 'success');
          };
        };
        
        // NOW do the signaling
        log('Native: Creating offer...', 'info');
        const offer = await pc1.createOffer();
        log('Native: Setting local description on PC1...', 'info');
        await pc1.setLocalDescription(offer);
        log('Native: Setting remote description on PC2...', 'info');
        await pc2.setRemoteDescription(offer);
        
        log('Native: Creating answer...', 'info');
        const answer = await pc2.createAnswer();
        log('Native: Setting local description on PC2...', 'info');
        await pc2.setLocalDescription(answer);
        log('Native: Setting remote description on PC1...', 'info');
        await pc1.setRemoteDescription(answer);
        
        log('Native: Signaling complete', 'success');
        log(`Native: PC1 local desc type: ${pc1.localDescription?.type}`, 'info');
        log(`Native: PC2 local desc type: ${pc2.localDescription?.type}`, 'info');
        log(`Native: PC1 remote desc type: ${pc1.remoteDescription?.type}`, 'info');
        log(`Native: PC2 remote desc type: ${pc2.remoteDescription?.type}`, 'info');
        
        // Wait for ICE gathering to complete
        await new Promise(resolve => setTimeout(resolve, 2000));
        
        // NOW add all the candidates
        log(`Native: Adding ${pc1Candidates.length} candidates to PC1...`, 'info');
        for (const candidate of pc1Candidates) {
          try {
            await pc1.addIceCandidate(candidate);
          } catch (err) {
            log(`Native: PC1 add candidate error: ${err.message}`, 'error');
          }
        }
        
        log(`Native: Adding ${pc2Candidates.length} candidates to PC2...`, 'info');
        for (const candidate of pc2Candidates) {
          try {
            await pc2.addIceCandidate(candidate);
          } catch (err) {
            log(`Native: PC2 add candidate error: ${err.message}`, 'error');
          }
        }
        
        log('Native: All candidates added, waiting for connection...', 'success');
        
        // Wait longer to see connection progress
        await new Promise(resolve => setTimeout(resolve, 5000));
        
        log(`Native: Final PC1 ICE state: ${pc1.iceConnectionState}`, 'info');
        log(`Native: Final PC2 ICE state: ${pc2.iceConnectionState}`, 'info');
        log(`Native: Final PC1 connection state: ${pc1.connectionState}`, 'info');
        log(`Native: Final PC2 connection state: ${pc2.connectionState}`, 'info');
        log(`Native: Data channel state: ${dataChannel.readyState}`, 'info');
        
      } catch (error) {
        log(`Native error: ${error.message}`, 'error');
        console.error('Native error:', error);
      }
    };

    // Make functions available globally
    window.createPigeonRTC = createPigeonRTC;
  </script>
</body>
</html>
